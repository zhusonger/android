# 零、大括号
大括号就是一个作用域的范围，还没有研究JVM虚拟机相关的，猜测就是通过这个符号，在汇编的时候处理成起始与结束。

# 一、变量的种类
1. 静态全局变量 (在类的作用域内)
2. 非静态全局变量 (在类对象的作用域)
3. 局部变量 (在方法的作用域)

生命周期: 静态的全局变量生命周期最长，非静态的次之，局部变量的生命周期最短, 生命周期越长，那占用内存的时间也就越久，所以使用的优先级依次为局部变量 > 非静态全局变量 > 静态的全局变量

# 二、JVM内存模型
JVM的内存模型的知识点很多，我们现在只针对变量在内存模型中的表现这个进行了解。

JVM内存模型:
![alt](https://github.com/zhusonger/android/blob/master/resources/ef-8-45-2.png?raw=true)

共享区: 

    __堆区__: 存放类的实例,Integer也属于类, int不属于类, 要注意区分他们的区别
  
    __方法区__: 存放类的信息、常量、静态变量等，由于 __静态变量__ 也属于类级别的信息，
    存放在方法区，它的生命周期跟虚拟机的生命周期一样长，所以它占用的内存空间时间
    是最长的，在不是必要的情况下，就可以考虑不用它。
 
私有区:
   只说下虚拟机栈，另外2个先不管，关系不大。
  
    __虚拟机栈__: 每一个虚拟机有一个私有的栈内存，存放一个个栈帧，
    在虚拟机启动的时候，会去查询main方法，所以main方法可以看做
    是这个栈的底，在Android中，应用的启动其实也是通过
    ActivityThread的main方法来启动一个App的进程(虚拟机)的。
    在创建某个类的实例的时候，首先被压入栈中的是类的变量，也就是 
    __非静态全局变量__，然后再调用类的某个方法时，会首先压入方法
    的参数到栈中，然后是方法中的__局部变量__, 在方法调用结束之后(大括号结束)，
    就会把这个作用域的变量个出栈,那在这个作用域范围的局部变量就没
    有再有任何使用的地方了，在垃圾回收器GC的时候，就会把它回收
    掉。
    
    从这里也可以看出，类的作用域范围大于方法的作用域范围，所以释
    放局部变量的时机会早于类的时机，所以在不是其他地方也需要用到
    这个变量的情况下，把变量定义成局部变量，会更优于GC。
    
# 三、局部变量的优化
在理解完变量的使用之后，我们再回归主题，局部变量的作用域最小化。
根据Effective Java的建议,主要有以下几个方面:
1. 在初次使用的地方定义局部变量，一个是便于理解，另外一个就是上面虚拟机栈中所说的，在执行到有定义局部变量的时候，才会入栈变量，那越迟定义，入栈的时候就越晚，想当与缩短了局部变量占用内存的时间。
2. 在定义一个局部变量时，最有效的判断是否是最晚定义，可以通过定义后能直接初始化赋值来判断。除了try-catch的情况, 比如要在try-catch外使用，但是赋值有可能抛出异常。
3. for循环的Loop variable,在for循环的第一个分号前面，可以定义循环变量，这个变量的范围作用域就在for循环内, 进一步缩小作用域的范围, 还是有点道理的，原理同2，在for循环结束之后，就出栈了，如果是定义在for循环外面的情况，就会在for循环所在方法执行结束之后出栈。
4. for循环的Loop variable的功能，可以减少复制粘贴的错误，因为只在for循环内有效，即使复制粘贴，也是对当前for循环有效。如下:
 ```
  Iteator<Element> i = c.iterator();
  while(i.hasNext()) {
    doSomething(i.next());
  }
  
  Iteator<Element> i2 = c2.iterator();
  // 这里的i忘记改了, 是不是感觉有点熟悉
  // 还很隐蔽，不容易被发现，因为不会报错也不会崩溃，只是数据不对
  while(i.hasNext()) { 
    doSomething(i2.next());
  }
  
  
  for(Iteator<Element> i = c.iterator(); i.hasNext(); ) {
    doSomething(i.next());
  }
  // 这里的i我们也忘记改了，但是这里会报错，说找不到i
  // 那么复制粘贴错误，在这里被发现的几率就更大了，而且
  // 而且其实都不需要去改i2,直接用i就可以，因为只是临时
  // 遍历需要的变量,在上一个for循环结束已经不在当前栈中了
  for(Iteator<Element> i2 = c2.iterator(); i.hasNext(); ) {
    doSomething(i2.next());
  }
```  

# 五: TODO
更多内存模型相关的知识，我们在学JVM虚拟机的时候再去了解。

参考链接: 
* 全面理解Java内存模型: <https://blog.csdn.net/suifeng3051/article/details/52611310>
* JVM内存模型: <https://www.jianshu.com/p/1579aafac60b>
* 方法调用内存分配情况: <https://blog.csdn.net/lazyer_dog/article/details/47127581>