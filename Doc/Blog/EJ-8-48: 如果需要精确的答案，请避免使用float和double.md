# float与double为什么不准确
![alt](https://github.com/zhusonger/android/blob/master/resources/ef-8-48-1.png?raw=true)
从图中可以看出，在小数点后依次表示的是0.5,0.25,0.125...
那么假如我们要表示0.1是怎么个过程呢

二进制 | 结果 | 命中
------- | ------- | -------  
0.1 | 0.5 | false  
0.01 | 0.2 | false
0.001 | 0.125 | false
0.0001 | 0.0625 | false   

到这里，有没有发现问题的关键，0.1的二进制在0.001与0.0001之间, 没有准确的值，那么，怎么才能表示0.1呢，那只有无限逼近0.1,并不能准确表示0.1. 


二进制 | 结果 | 命中(相加逼近0.1)
------- | ------- | -------  
0.0001 | 0.0625 | true  ==> 0.0001(0.0625)
0.00001 | 0.03125 | true ==> 0.00011(0.0625+0.03125=0.09375)
0.000001 | 0.015625 | false(加上之后超出)
0.0000001 | 0.0078125 | false(加上之后超出)
0.00000001 | 0.00390625 | true ==> 0.00011001(0.09765625)

就是这样慢慢无限逼近这个值

## float与double的区别
float和double经常说double比float精确，那为什么精确，float是单精度的，double是双精度的，那单精度和双精度又是什么呢。

其实就是用来表示尾数(小数点后面的数值)的二进制位数，位数越多，越接近我们期望的值，double比float位数二进制多很多位，所以精度更高。

## 怎么解决精确计算

上一节中说过使用java提供的类库，这里就是用到了math里的一个类，BigDecimal，要注意的是，使用它来表示小数的时候，要使用BigDecimal(String.class)或者BigDecimal.valueOf(double), 第二个构造方法必须是double, float还是会不精确，这里应该是double的转换问题，我看了下也没看懂。

还有一种方法是把计算的单位调整，调整到最小的单位，然后就是int和long的计算了，不过这个只适用于数值不超过int或long范围的计算

# 参考链接:
<https://blog.csdn.net/gege87417376/article/details/79550749>
<https://juejin.im/entry/575543857db2a2006993114e>