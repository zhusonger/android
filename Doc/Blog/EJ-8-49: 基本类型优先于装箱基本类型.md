# 数据类型
 
* 基本类型(primitive) 
      如int,long,boolean等
* 装箱基本类型(boxed primitive)
      对应基本类型的装箱类型，如Integer,Long,Boolean等
* 引用类型(reference type)
      类似于C/C++中的指针(但不是指针,可以理解为别名)，在内存空间的堆中创建一块区域，存放原始数据，引用类型指向原始数据的内存地址
      
# 装箱/拆箱
在JDK1.5之后，Java增加了自动装箱(autoboxing)与自动拆箱(auto-unboxing)的功能，所有涉及到装箱基本类型与基本类型的混合使用，装箱类型就会自动拆箱

```
  Integer a = 1; // 1
  int b = 5; // 2
  int sum = a + b; // 3
  Integer sum2 = a + b; // 4
```  
上面这个小例子，涉及到的装箱拆箱有哪些? 在文末给出答案。

# 同一性与等同性

* 同一性: 表示2个东西完全相同，基本类型如果值相同，那么可以肯定的就是满足同一性的
 ```
    int a = 1;
    int b = 1;
    System.out.println("是否是满足同一性:" + (a == b)); // true
 ```

* 等同性: 表示2个东西__逻辑__上是相等的，但是可能是不同的东西。比如2个女孩，不是同一个人，但是针对性别来说，她们是相等的。这就是等同性。
 ```
    Integer a = 1;
    Integer b = 1;
    System.out.println("是否是满足同一性:" + (a == b)); // false
    System.out.println("是否是满足等同性:" + (a.equals(b))); // true
 ```

# 空间与时间
由于装箱类型比基本类型多了一个装箱/拆箱的过程，那肯定是需要额外的空间与时间来做这件事情，所以装箱类型会比基本类型更耗时和空间。所以如果可以的话，尽量使用基本类型，在数据量少的情况下可能看不出差别，但是数据量大的情况就会有明显的差异。

```
  int sum;
  for(int i = 0; i < 100000; i++) {
    sum = sum + i;
  }
  
  Integer sum2 = 0; 
  // 必须初始化一个值, 否则编译出错，因为默认值是null,
  // 在进行装箱拆箱的时候会报NullPointerException
  for(int i = 0; i < 100000; i++) {
    // 需要拆箱做加法，然后再装箱重新赋值给sum2,每次
    // 循环都多做了2次操作
    sum2 = sum2 + i; 
  }
```  

# 必须要用装箱类型的情况
* 集合（Collection）: 集合中不允许存放基本类型，所以我们只能使用装箱类型。
* 类型参数(<Type>) : 其实就是泛型，泛型也不允许是基本类型
* 反射: 在反射的调用中，反射的基本原理是基于Class的，所以如果要调用反射的一系列方法，只能使用装箱类型，但是不是说基本类型在反射中就没办法了，这里指的是调用对象的反射方法，因为对象有提供方法，而基本类型只有值，没有提供方法。

# 答案

```
  Integer a = 1; // 1
  int b = 5; // 2
  int sum = a + b; // 3
  Integer sum2 = a + b; // 4
``` 
1: 执行了自动装箱
2: 没有装箱拆箱
3: a + b中，a执行了拆箱
4: a + b中，a执行了拆箱, sum的赋值执行了装箱

# 陷阱
以下等式判断，结果是什么
```
int a = 1;
int b = 1;
Integer c = 1;
Integer d = 1;

a == b; // 1
a == c; // 2
c == d; // 3
```  

行数 | 结果
------- | -------
1 | 
2 | 
3 | 


